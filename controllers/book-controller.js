import Book from '../models/book';
import Genre from '../models/genre';
import { UserController } from './user-controller';
import { GenreController } from './genre-controller';
import { filterAsync, mapAsync } from '../helpers/async-helper';


export class BookController {
  constructor(options) {
    if (options.book) {
      this.book = options.book;
    } else if (options.id) {
      this.book = BookController.findBookByID(options.id);
    }
  }

  async checkThatBookExists() {
    try {
      this.book = await this.book;
    } catch (err) {
      console.log('Error occured while finding book.');
      console.log(err);
      return false;
    }
    return this.book != null;
  }

  static findBookByID(id) {
    return new Promise((resolve, reject) => {
      Book.findById(id).populate('genre').populate('owner').exec((err, user) => {
        if (err) return reject(err);
        return resolve(user);
      });
    });
  }

  /*
    @param {Object} options - Object specifying what info to be returned.
      ownerUsername: Display username.
    @return {Object} - Object containing required info. Compulsory info:
      title
      author
      genre
      description
      dateListed
      id
  */
  async getBookInfo(options) {
    if (!(await this.checkThatBookExists())) return null;

    const toBeReturned = {
      title: this.book.title,
      author: this.book.author,
      genre: this.book.genre.title,
      description: this.book.description,
      dateListed: this.book.dateListed.getTime(),
      id: this.book.id,
    };

    if (options.ownerUsername) {
      toBeReturned.ownerUsername = this.book.owner.username;
    }

    return toBeReturned;
  }

  populateGenre() {
    return new Promise(async (resolve, reject) => {
      Genre.findById(this.book.genre, (err, genreObject) => {
        if (err) return reject(err);
        this.book.genre = genreObject;
        return resolve();
      });
    });
  }
}

/*
  @param {request} req - The request object that contains body and headers. Request must contain:
    1) Title
    2) Author
    3) Genre
    4) Additional description (optional)
  @param {response} res - The response object used to send response codes and data to client.

  User is already checked for authentication prior to the calling of this function.
  Checks to make sure header is 'content-type':'application/json'.
  Then ensures that the required fields are valid. Note that the date listed parameter is
  generated by the server based on the time of request received.
  After that create new book and save in database under the user. The user is obtained from the
  authenticated session parameter.

  @return {response} res - Sends response code 200 for success in creation of new book. Otherwise,
  sends 400 with a json body that specifies { error }.
*/
export const createBook = async (req, res) => {
  if (!req.body) return res.status(400).json({ success: false, error: 'Use JSON!' });

  // Preliminary checks for existence of required parameters.
  if (!req.body.title || !req.body.author || !req.body.genre || req.body.genre.length < 1) {
    return res.status(400).json({ success: false, error: 'Missing or invalid parameters.' });
  }

  // Making sure critical parameters are not blank.
  req.checkBody('title', 'Title cannot be blank.').notEmpty();
  req.checkBody('author', 'Author cannot be blank.').notEmpty();

  const validationResult = await req.getValidationResult();
  if (!validationResult.isEmpty()) {
    return res.status(400).json({ success: false, error: validationResult.array()[0].msg });
  }

  // Check that genre is valid.
  const genreController = new GenreController({ title: req.body.genre });
  const genreExists = await genreController.checkThatGenreExists();
  if (!genreExists) return res.status(400).json({ success: false, error: 'Invalid genre.' });

  // User is authenticated so this is not required, but just to be sure...
  const callingUser = new UserController({ username: req.session.auth.username });
  const userExists = await callingUser.checkThatUserExists();
  if (!userExists) return res.status(400).json({ success: false, error: 'User doesnt exist.' });

  const newBook = new Book();
  newBook.title = req.body.title;
  newBook.author = req.body.author;
  newBook.dateListed = new Date();
  newBook.owner = callingUser.user.id;
  newBook.genre = genreController.genre.id;
  newBook.description = req.body.description || '';
  return newBook.save(async (err, book) => {
    if (err) return res.status(400).json({ success: false, error: 'Error saving book.' });
    try {
      await callingUser.addBook(book.id);
      return res.status(200).json({ success: true });
    } catch (error) {
      console.log('An error has occured while adding book to user: ');
      console.log(err);
      return res.status(400).json({ success: false, error: 'Error saving book.' });
    }
  });
};

/*
  @param {Integer} from - The nth entry to start at. (inclusive)
  @param {Integer} to - The nth entry to end at. (inclusive)
  @return Promise{Array{Book}} - The array of most recent nth to nth books.

  Used by books router to get the n most recent books. Note that this implementation will
  return the list that is loaded from mongoose if the from-to range is smaller than list length.
  No validation is done so all callers must do their own validation
*/
export const getRecentBooks = (from, to) =>
  new Promise((resolve, reject) => {
    Book.find({}).sort({ dateListed: -1 }).limit(to + 1).populate('genre', 'title')
    .populate('owner', 'username')
    .exec(async (err, books) => {
      if (err) return reject(err);
      let slicedBooks = books;
      if (from >= books.length) {
        return resolve([]);
      }
      slicedBooks = books.slice(from, to + 1);

      const mappedBooks = await mapAsync(slicedBooks, (book, callback) => {
        const bookController = new BookController({ book });
        bookController.getBookInfo({ ownerUsername: true }).then(info =>
          callback(null, info));
      });

      return resolve(mappedBooks);
    });
  });
